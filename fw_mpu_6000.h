#ifndef MPU_6000_H__
#define MPU_6000_H__

#include <stdint.h>

typedef double module_data_t; // this uses double precision

#define NUMBER_OF_AXES                       3 /* X axis, Y axis, Z axis */
#define SAMPLING_FREQ_HZ                    100

#define MODULE_INT_PIN                          31

#define REG_SELF_TEST_X                       0x0D
#define REG_SELF_TEST_Y                       0x0E
#define REG_SELF_TEST_Z                       0x0F
#define REG_SELF_TEST_A                       0x10
#define REG_SMPLRT_DIV                         0x19
/* Ref. datasheet
 * This register specifies the divider from the gyroscope output rate used to generate the Sample Rate for the MPU-60X0.
 * The sensor register output, FIFO output, and DMP sampling are all based on the Sample Rate.
 * The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:
 * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
 * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7),
 * and 1kHz when the DLPF is enabled (see Register 26).
 */
 #define FREQ_TO_REG_VAL(F)                    ((uint8_t)(1000/F) - 1)   /* Reverse of Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV) */
 
 
#define REG_CONFIG                                    0x1A	 /* This register configures the external Frame Synchronization (FSYNC) pin sampling and the Digital Low Pass Filter (DLPF) setting for both the gyroscopes and accelerometers.*/
#define CONFIG_EXT_SYNC_DISABLE              0x00

#define CONFIG_DLPF_CFG3                         0x03  /*  Accel's Bandwidth(Hz) 44, delay(ms) 4.9 & Gyro's data output rate(kHz) 1, Bandwidth(Hz) 42, delay(ms) 4.8 */
#define CONFIG_DLPF_CFG4                         0x04  /*  Accel's Bandwidth(Hz) 21, delay(ms) 8.5 & Gyro's data output rate(kHz) 1, Bandwidth(Hz) 20, delay(ms) 8.3 */
#define CONFIG_DLPF_CFG5                         0x05  /*  Accel's Bandwidth(Hz) 10, delay(ms) 13.8 & Gyro's data output rate(kHz) 1, Bandwidth(Hz) 10, delay(ms) 13.4 */
#define CONFIG_DLPF_CFG6                         0x06  /*  Accel's Bandwidth(Hz) 5, delay(ms) 19.0 & Gyro's data output rate(kHz) 1, Bandwidth(Hz) 5, delay(ms) 18.6 */
/* Ref. datasheet
 * The accelerometer output rate is 1kHz. This means that for a Sample Rate (Data output rate) greater than 1kHz,
 * the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once.
 */

#define REG_GYRO_CONFIG                          0x1B	 /* This register is used to trigger gyroscope self-test and configure the gyroscopes’ full scale range.*/
#define GYRO_CONFIG_FS_SEL0                    0x00	 /* ± 250 °/s.*/
#define GYRO_CONFIG_FS_SEL1                    0x01	 /* ± 500 °/s.*/
#define GYRO_CONFIG_FS_SEL2                    0x02	 /* ± 1000 °/s.*/
#define GYRO_CONFIG_FS_SEL3                    0x03	 /* ± 2000 °/s.*/

#define REG_ACCEL_CONFIG 		                    0x1C	/* This register is used to trigger accelerometer self test and configure the accelerometer full scale range. This register also configures the Digital High Pass Filter (DHPF). */
#define ACCEL_CONFIG_FS_SEL0                   0x00	 /* ± 2g.*/
#define ACCEL_CONFIG_FS_SEL1                   0x01	 /* ± 4g.*/
#define ACCEL_CONFIG_FS_SEL2                   0x02	 /* ± 8g.*/
#define ACCEL_CONFIG_FS_SEL3                   0x03	 /* ± 16g.*/

#define REG_FIFO_EN                                   0x23
/* Ref. datasheet
 * This register determines which sensor measurements are loaded into the FIFO buffer.
 * Data stored inside the sensor data registers (Registers 59 to 96) will be loaded into the FIFO buffer
 * if a sensor’s respective FIFO_EN bit is set to 1 in this register.
 * 
 * The MPU-60X0 contains a 1024-byte FIFO register that is accessible via the Serial Interface (SPI or I2C).
 * The FIFO configuration register determines which data is written into the FIFO.
 * Possible choices include gyro data, accelerometer data, temperature readings, auxiliary sensor readings, and FSYNC input.
 * A FIFO counter keeps track of how many bytes of valid data are contained in the FIFO.
 * The FIFO register supports burst reads.
 * The interrupt function may be used to determine when new data is available.
 *
 * Items that can trigger an interrupt are
 * (1) Clock generator locked to new reference oscillator (used when switching clock sources)
 * (2) new data is available to be read (from the FIFO and Data registers)
 * (3) accelerometer event interrupts
 * (4) the MPU-60X0 did not receive an acknowledge from an auxiliary sensor on the secondary I2C bus
 * The interrupt status can be read from the Interrupt Status register.
 */
#define FIFO_EN_TEMP_FIFO_ENABLE            0x80  /* When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the FIFO buffer.*/
#define FIFO_EN_XG_FIFO_ENABLE                0x40  /* When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the FIFO buffer.*/
#define FIFO_EN_YG_FIFO_ENABLE                0x20  /* When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the FIFO buffer.*/
#define FIFO_EN_ZG_FIFO_ENABLE                0x10  /* When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the FIFO buffer.*/
#define FIFO_EN_ACCEL_FIFO_ENABLE          0x08  /* When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the FIFO buffer.*/

#define REG_I2C_MST_CTRL 		                      0x24 
#define REG_I2C_SLV0_ADDR 	                    	0x25 
#define REG_I2C_SLV0_REG 	                      	0x26 
#define REG_I2C_SLV0_CTRL 		                    0x27 
#define REG_I2C_SLV1_ADDR                      		0x28 
#define REG_I2C_SLV1_REG 		                      0x29 
#define REG_I2C_SLV1_CTRL 	                    	0x2A 
#define REG_I2C_SLV2_ADDR 	                     	0x2B 
#define REG_I2C_SLV2_REG 		                      0x2C 
#define REG_I2C_SLV2_CTRL                      		0x2D 
#define REG_I2C_SLV3_ADDR                     		0x2E 
#define REG_I2C_SLV3_REG 	                      	0x2F 
#define REG_I2C_SLV3_CTRL                     		0x30 
#define REG_I2C_SLV4_ADDR 	                     	0x31 
#define REG_I2C_SLV4_REG 		                      0x32 
#define REG_I2C_SLV4_DO 		                        0x33 
#define REG_I2C_SLV4_CTRL 		                    0x34 
#define REG_I2C_SLV4_DI                           		0x35 
#define REG_I2C_MST_STATUS 	                  	0x36 

#define REG_INT_PIN_CFG 		                        0x37	/* This register configures the behavior of the interrupt signals at the INT pins.*/
#define INT_PIN_CFG_LEVEL_ACTIVE_LOW     0x80  /* When this bit is equal to 1, the logic level for the INT pin is active low.*/
#define INT_PIN_CFG_LEVEL_ACTIVE_HIGH     0x00  /* When this bit is equal to 1, the logic level for the INT pin is active high.*/
// active low/high = the input will go low/high when the switch is closed
#define INT_OPEN_PUSH_PULL                      0x00
#define INT_OPEN_OPEN_DRAIN                     0x40
#define INT_PIN_PULSE_EMIT_ENABLE           0x00  /* When LATCH _INT_EN bit is equal to 0, the INT pin emits a 50us long pulse.*/
#define INT_PIN_LATCH_INT_ENABLE              0x20  /* When this bit is equal to 1, the INT pin is held high until the interrupt is cleared. */
#define INT_PIN_INT_READ_CLEAR                  0x10  /* When this bit is equal to 0, interrupt status bits are cleared only by reading INT_STATUS (Register 58) */

#define REG_INT_ENABLE 		                         	0x38 	/* This register enables interrupt generation by interrupt sources.*/
#define INT_ENABLE_FIFO_OVERFLOW           0x10   /* When set to 1, this bit enables a FIFO buffer overflow to generate an interrupt. */
#define INT_ENABLE_DATA_READY                 0x01   /* When set to 1, this bit enables the Data Ready interrupt, which occurs each time a write operation to all of the sensor registers has been completed.*/

#define REG_INT_STATUS 			                        0x3A 	/*  (Type: Read Only) This register shows the interrupt status of each interrupt generation source. Each bit will clear after the register is read.*/
#define INT_STATUS_DATA_READY                 INT_ENABLE_DATA_READY
#define INT_STATUS_FIFO_OVERFLOW           INT_ENABLE_FIFO_OVERFLOW

#define REG_ACCEL_XOUT_H 		0x3B 
#define REG_ACCEL_XOUT_L 		0x3C 
#define REG_ACCEL_YOUT_H 		0x3D 
#define REG_ACCEL_YOUT_L 		0x3E 
#define REG_ACCEL_ZOUT_H 		0x3F 
#define REG_ACCEL_ZOUT_L 		0x40
/* Ref. datasheet (Type: Read Only)
 * These registers store the most recent accelerometer measurements.
 * Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25 (REG_SMPLRT_DIV).
 * The accelerometer measurement registers, along with the temperature measurement registers,
 * gyroscope measurement registers, and external sensor data registers, are composed of two sets of registers:
 * an internal register set and a user-facing read register set.
 */

#define REG_TEMP_OUT_H 			0x41 
#define REG_TEMP_OUT_L 			0x42
/* Ref. datasheet (Type: Read Only)
 * These registers store the most recent temperature sensor measurement.
 * Temperature measurements are written to these registers at the Sample Rate as defined in Register 25 (REG_SMPLRT_DIV).
 * These temperature measurement registers, along with the accelerometer measurement registers,
 * gyroscope measurement registers, and external sensor data registers, are composed of two sets of registers:
 * an internal register set and a user-facing read register set.
 *
 * The data within the temperature sensor’s internal register set is always updated at the Sample Rate.
 * The scale factor and offset for the temperature sensor are found in the Electrical Specifications table
 * (Section 6.4 of the MPU-6000/MPU-6050 Product Specification document).
 *
 * The temperature in degrees C for a given register value may be computed as:
 * Temperature in degrees C = (TEMP_OUT Register Value as a signed quantity)/340 + 36.53
 * Please note that the math in the above equation is in decimal.
 */

#define REG_GYRO_XOUT_H 		0x43 
#define REG_GYRO_XOUT_L 		0x44 
#define REG_GYRO_YOUT_H 		0x45 
#define REG_GYRO_YOUT_L 		0x46 
#define REG_GYRO_ZOUT_H 		0x47 
#define REG_GYRO_ZOUT_L 		0x48 
/* Ref. datasheet (Type: Read Only)
 * TThese registers store the most recent gyroscope measurements.
 * Gyroscope measurements are written to these registers at the Sample Rate as defined in Register 25 (REG_SMPLRT_DIV).
 */

#define REG_EXT_SENS_DATA_00 	0x49 
#define REG_EXT_SENS_DATA_01 	0x4A 
#define REG_EXT_SENS_DATA_02 	0x4B 
#define REG_EXT_SENS_DATA_03 	0x4C 
#define REG_EXT_SENS_DATA_04 	0x4D 
#define REG_EXT_SENS_DATA_05 	0x4E 
#define REG_EXT_SENS_DATA_06 	0x4F 
#define REG_EXT_SENS_DATA_07 	0x50 
#define REG_EXT_SENS_DATA_08 	0x51 
#define REG_EXT_SENS_DATA_09 	0x52 
#define REG_EXT_SENS_DATA_10 	0x53 
#define REG_EXT_SENS_DATA_11 	0x54 
#define REG_EXT_SENS_DATA_12 	0x55 
#define REG_EXT_SENS_DATA_13 	0x56 
#define REG_EXT_SENS_DATA_14 	0x57 
#define REG_EXT_SENS_DATA_15 	0x58 
#define REG_EXT_SENS_DATA_16 	0x59 
#define REG_EXT_SENS_DATA_17 	0x5A 
#define REG_EXT_SENS_DATA_18 	0x5B 
#define REG_EXT_SENS_DATA_19 	0x5C 
#define REG_EXT_SENS_DATA_20 	0x5D 
#define REG_EXT_SENS_DATA_21 	0x5E 
#define REG_EXT_SENS_DATA_22 	0x5F 
#define REG_EXT_SENS_DATA_23 	0x60 
#define REG_I2C_SLV0_DO 		0x63 
#define REG_I2C_SLV1_DO 		0x64 
#define REG_I2C_SLV2_DO 		0x65 
#define REG_I2C_SLV3_DO 		0x66 
#define REG_I2C_MST_DELAY_CTRL	0x67

#define REG_SIGNAL_PATH_RESET	                  0x68	/* This register is used to reset the analog and digital signal paths of the gyroscope, accelerometer, and temperature sensors.*/
#define SIGNAL_PATH_RESET_GYRO                0x04  /*  This bit resets the gyroscope analog and digital signal paths.*/
#define SIGNAL_PATH_RESET_ACCEL               0x02  /*  This bit resets the accelerometer analog and digital signal paths.*/
#define SIGNAL_PATH_RESET_TEMP                 0x01  /*  This bit resets the temperature sensor analog and digital signal paths.*/
#define RESET_DELAY_SIGNAL_PATH_RESET      100

/*To prevent switching into I2C mode when using SPI (MPU-6000), the I2C interface should be disabled by setting the I2C_IF_DIS configuration bit.
 * Setting this bit should be performed immediately after waiting for the time specified by the “Start-Up Time for Register Read/Write” in Section 6.3.
 */
#define REG_USER_CTRL		                            	0x6A	
/* Ref. datasheet
 * This register allows the user to enable and disable the FIFO buffer, I2C Master Mode, and primary I2C interface.
 * The FIFO buffer, I2C Master, sensor signal paths and sensor registers can also be reset using this register.
 */
#define USER_CTRL_FIFO_EN                           0X40 /* When set to 1, this bit enables FIFO operations. */
#define USER_CTRL_I2C_MST_EN                     0X20
#define USER_CTRL_I2C_IF_DIS                        0X10  /* When set to 1, this bit disables the primary I2C interface and enables the SPI interface instead. */
#define USER_CTRL_FIFO_RESET                     0X04  /* This bit automatically clears to 0 after the reset has been triggered.*/
#define USER_CTRL_SETTINGS                        USER_CTRL_I2C_IF_DIS | USER_CTRL_FIFO_EN
 
 
 /* This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0.
  * This bit automatically clears to 0 after the reset has been triggered.
	*/
 #define USER_CTRL_I2C_MST_RESET                0X02
 #define USER_CTRL_SIG_COND_RESET             0X01

#define REG_PWR_MGMT_1			                        0x6B	 /* DEVICE_RESET[7], CLOCKSELECT[2:0], Clock source select for sampling */
#define PWR_MGMT_1_DEVICE_RESET               0x80
#define RESET_DELAY_PWR_MGMT_1                200
/* Ref. datasheet
 * When using SPI interface, user should use DEVICE_RESET (register 107) as well as
 * SIGNAL_PATH_RESET (register 104) to ensure the reset is performed properly.
 * The sequence used should be:
 * 1. Set DEVICE_RESET = 1 (register PWR_MGMT_1)
 * 2. Wait 100ms
 * 3. Set GYRO_RESET = ACCEL_RESET = TEMP_RESET = 1 (register SIGNAL_PATH_RESET)
 * 4. Wait 100ms
 */
#define PWR_MGMT_1_CLKSEL0                       0x00
#define PWR_MGMT_1_CLKSEL1                       0x01  /* PLL with X axis gyroscope reference */
#define PWR_MGMT_1_CLKSEL2                       0x02  /* PLL with Y axis gyroscope reference */
#define PWR_MGMT_1_CLKSEL3                       0x03  /* PLL with Z axis gyroscope reference */
#define PWR_MGMT_1_CLKSEL4                       0x04  /* PLL with external 32.768kHz reference */
/* Ref. datasheet
 * It is highly recommended that the device be configured to use one of the gyroscopes
 * (or an external clock source) as the clock reference for improved stability.
 */
#define PWR_MGMT_1_CLK_SETTING_DELAY     10  /* PLL Settling Time delay*/
 /* Ref. datasheet - Electrical Specifications
 * Conditions -  CLK_SEL == 1,2,3 (Using INTERNAL CLOCK SOURCE)
 * Typical PLL Settling Time = 1 ms
 * Max PLL Settling Time = 10 ms
 */
 
#define REG_PWR_MGMT_2			                         0x6C
#define REG_FIFO_COUNTH			                           0x72
#define REG_FIFO_COUNTL			                           0x73
#define REG_FIFO_R_W			                                 0x74

#define REG_WHO_AM_I			                               0x75
#define EXPECTED_VALUE_WHO_AM_I                0x68

#define REG_ADDR_TO_READ                             {REG_ACCEL_XOUT_H, \
                                                                             REG_ACCEL_XOUT_L, \
                                                                             REG_ACCEL_YOUT_H, \
                                                                             REG_ACCEL_YOUT_L, \
                                                                             REG_ACCEL_ZOUT_H, \
                                                                             REG_ACCEL_ZOUT_L, \
                                                                             REG_GYRO_XOUT_H, \
                                                                             REG_GYRO_XOUT_L, \
                                                                             REG_GYRO_YOUT_H, \
                                                                             REG_GYRO_YOUT_L, \
                                                                             REG_GYRO_ZOUT_H, \
                                                                             REG_GYRO_ZOUT_L, \
                                                                             REG_TEMP_OUT_H, \
                                                                             REG_TEMP_OUT_L}

typedef struct module_raw_data{
		
		uint8_t accel_xout_h;
		uint8_t accel_xout_l;
		uint8_t accel_yout_h;
		uint8_t accel_yout_l;
		uint8_t accel_zout_h;
		uint8_t accel_zout_l;
		
		uint8_t gyro_xout_h;
		uint8_t gyro_xout_l;
		uint8_t gyro_yout_h;
		uint8_t gyro_yout_l;
		uint8_t gyro_zout_h;
		uint8_t gyro_zout_l;
		
		uint8_t temp_out_h;
		uint8_t temp_out_l;
	
} module_raw_data_t;

typedef struct module_calibration_value{
		
		uint16_t                 sensitivity_accel;
		uint8_t                  sensitivity_gyro;
		uint16_t                  denom_temp;
		module_data_t      add_temp;
	
}module_cal_value_t;

typedef struct module_calibrate_data{
		
		module_cal_value_t cal;
		
		module_data_t      a_x; // accel value
		module_data_t      a_y;
		module_data_t      a_z;
		
		module_data_t      gyro_x;
		module_data_t      gyro_y;
		module_data_t      gyro_z;
		
		module_data_t      temp; // temperature value of the module
	
		module_data_t      v_x; // velocity
		module_data_t      v_y;
		module_data_t      v_z;
	
		module_data_t      d_x; // displacement (location)
		module_data_t      d_y;
		module_data_t      d_z;

		
}module_cal_data_t;


/**
 * @brief Init the accel / gyro module
 */
void fw_module_init(void);

/**
 * @brief Reset the accel / gyro module
 */
void fw_module_reset(void);

/**
 * @brief Enable module's interrupt
 */
void fw_read_int_status(void);

/**
 * @brief Enable module's interrupt
 */
void fw_enable_int(void);
																																						 
/**
 * @brief Read module's accel, gyro, temperature value
 */
void fw_read_data(void);

/**
 * @brief Get array which contains data register address
 */
const uint8_t * fw_get_data_reg_addr_array(void);

/**
 * @brief Get the length of array which contains data register address
 */
uint8_t fw_get_data_reg_addr_array_length(void);

/**
 * @brief Get the address of module's data which contains module's data
 */
module_cal_data_t * fw_get_module_data_addr(void);

/**
 * @brief Calibrate raw value to digital value
 * @param data high byte
 * @param data low byte
 * @param index (accel xyz or gyro xyz)
 * @param pointer (addresss of global variable)
 */
void fw_module_cal_accel_or_gyro_data(uint8_t byte_h, uint8_t byte_l, uint8_t index, module_cal_data_t * p_data);


/**
 * @brief Init variable which contains data of the module
 * @param event
 */
static void fw_module_data_init(module_cal_data_t * p_data);


#endif // MPU_6000_H__
